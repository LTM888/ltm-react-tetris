{"ast":null,"code":"export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\nexport const createStage = () => Array.from(Array(STAGE_HEIGHT), () => new Array(STAGE_WIDTH).fill([0, 'clear']));\nexport const checkCollistion = (player, stage, {\n  x: moveX,\n  y: moveY\n}) => {\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; y += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if ( // 2. Check that our move is inside the game areas height (y)\n        // We shouldn't go though the bottom of the play area\n        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] || // 3. Check that out move is inside the game areas width (x)\n        !stage[y + player.pos.y + moveY] // 4. Check that the cell was moving to isn't set to clear\n        ) {\n            return true;\n          }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/leighmartin/Desktop/react-tetris/src/gameHelpers.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollistion","player","stage","x","moveX","y","moveY","tetromino","length","pos"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,EAApB;AACP,OAAO,MAAMC,YAAY,GAAG,EAArB;AAEP,OAAO,MAAMC,WAAW,GAAG,MACvBC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,EAAgC,MAChC,IAAIE,KAAJ,CAAUH,WAAV,EAAuBK,IAAvB,CAA4B,CAAC,CAAD,EAAI,OAAJ,CAA5B,CADA,CADG;AAMP,OAAO,MAAMC,eAAe,GAAG,CAACC,MAAD,EAASC,KAAT,EAAgB;AAAEC,EAAAA,CAAC,EAAEC,KAAL;AAAYC,EAAAA,CAAC,EAAEC;AAAf,CAAhB,KAA2C;AACtE,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACM,SAAP,CAAiBC,MAArC,EAA6CH,CAAC,IAAI,CAAlD,EAAqD;AACjD,SAAI,IAAIF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBG,MAAvC,EAA+CH,CAAC,IAAI,CAApD,EAAuD;AAGnD;AACA,UAAIJ,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBF,CAApB,MAA2B,CAA/B,EAAkC;AAC9B,aACU;AACV;AACA,SAACD,KAAK,CAAEG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAArB,CAAL,CAAmCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KAAtD,CAAD,IAEA;AACI,SAACF,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CANV,CAOA;AAPA,UAQE;AACE,mBAAO,IAAP;AACH;AACJ;AACJ;AACJ;AACJ,CArBM","sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\n\nexport const createStage = () => \n    Array.from(Array(STAGE_HEIGHT), () => \n    new Array(STAGE_WIDTH).fill([0, 'clear'])\n)\n\n\nexport const checkCollistion = (player, stage, { x: moveX, y: moveY }) => {\n    for (let y = 0; y < player.tetromino.length; y += 1) {\n        for(let x = 0; x < player.tetromino[y].length; y += 1) {\n\n\n            // 1. Check that we're on an actual Tetromino cell\n            if (player.tetromino[y][x] !== 0) {\n                if (\n                          // 2. Check that our move is inside the game areas height (y)\n                // We shouldn't go though the bottom of the play area\n                !stage[ y + player.pos.y + moveY] [ x + player.pos.x + moveX] ||\n\n                // 3. Check that out move is inside the game areas width (x)\n                    !stage[y + player.pos.y + moveY]\n                // 4. Check that the cell was moving to isn't set to clear\n                ) {\n                    return true;\n                }\n            }\n        }\n    }\n};"]},"metadata":{},"sourceType":"module"}